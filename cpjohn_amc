##### cpjohn_amc.py
#####
##### "amc" stands for AM file configureration.
#####
##### It's a manual module made up for Analysis of Drosophila brain neuron
##### 3-D matrix data. This py module file contents functions below: 
#####


import numpy as np
import matplotlib.pyplot as plt
import os
import re


def soma_index(path_of_branches_txt):
    # Part of loading soma position (proto) in branch.txt
    brtxt_filename = str(path_of_branches_txt)
    target_bptxt = open(brtxt_filename, 'rt', encoding = 'utf8')
    read_bptxt = target_bptxt.read()[:1000]
    target_bptxt.close()
    trim_soma = re.findall('--*.\n[0-9]+ [0-9]+ [0-9]+ [0-9]+ [0-9]+ [0-9]+ [0-9]+\n--*.\n',read_bptxt)
    soma_index_proto = list(map(int, trim_soma[0].split('\n')[1].split(' ')[-5::-1]))
    return soma_index_proto

"""
def soma_position(path_of_branches_txt):
    # Part of loading soma position (proto) in branch.txt
    brtxt_filename = str(path_of_branches_txt)
    target_bptxt = open(brtxt_filename, 'rt', encoding = 'utf8')
    read_bptxt = target_bptxt.read()[:1000]
    target_bptxt.close()
    trim_soma = re.findall('--*.\n[0-9]+ [0-9]+ [0-9]+ [0-9]+ [0-9]+ [0-9]+ [0-9]+\n--*.\n',read_bptxt)
    soma_posi_proto = list(map(int, trim_soma[0].split('\n')[1].split(' ')[-5::-1]))
    return soma_posi_proto
"""

"""
def cali_soma_position(path_of_branches_txt, path_of_sfAM):
    # Part of loading soma position (proto) in branch.txt
    brtxt_filename = str(path_of_branches_txt)
    target_bptxt = open(brtxt_filename, 'rt', encoding = 'utf8')
    read_bptxt = target_bptxt.read()[:1000]
    target_bptxt.close()
    trim_soma = re.findall('--*.\n[0-9]+ [0-9]+ [0-9]+ [0-9]+ [0-9]+ [0-9]+ [0-9]+\n--*.\n',read_bptxt)
    soma_posi_proto = list(map(int, trim_soma[0].split('\n')[1].split(' ')[-5::-1]))
    # Part of loading calibration axis in SF.am
    sfAM_filename = str(path_of_sfAM)
    target_sfAM = open(sfAM_filename, 'rt', encoding = 'utf8')
    read_sfAM = target_sfAM.read()[:1000]
    target_sfAM.close()
    grab_ca = re.findall('Min. [X,Y,Z] = [0-9]+', read_sfAM)
    calibrate_axis = list(map(lambda x : int(x.split(' = ')[-1]),grab_ca))
    # Part of merge
    soma_posi = [0,0,0]
    for m in range(3):
        soma_posi[m] = int(soma_posi_proto[m] - calibrate_axis[m] + 1)
    return soma_posi
"""

def ep_index(path_of_EPAM):
    EPAM_filename = str(path_of_EPAM)
    target_EPAM = open(EPAM_filename, 'rt', encoding = 'utf8')
    read_EPAM = target_EPAM.read()
    target_EPAM.close()
    trim_EP1 = read_EPAM.split('@')[-1].split('\n')
    if '' in trim_EP1: trim_EP1.remove('')
    if '1' in trim_EP1: trim_EP1.remove('1')
    trim_EP2 = list(map(lambda x: list(map(int,x.split(' '))), trim_EP1)) # 3D data
    return trim_EP2

"""
def cali_EP_position(path_of_EPAM, path_of_SFAM):
    # Part of loading EP position
    EPAM_filename = str(path_of_EPAM)
    target_EPAM = open(EPAM_filename, 'rt', encoding = 'utf8')
    read_EPAM = target_EPAM.read()
    target_EPAM.close()
    trim_EP1 = read_EPAM.split('@')[-1].split('\n')
    if '' in trim_EP1: trim_EP1.remove('')
    if '1' in trim_EP1: trim_EP1.remove('1')
    trim_EP2 = list(map(lambda x: list(map(int,x.split(' '))), trim_EP1)) # 3D data
    # Part of loading calibration axis in SF.am
    sfAM_filename = path_of_SFAM
    target_sfAM = open(sfAM_filename, 'rt', encoding = 'utf8')
    read_sfAM = target_sfAM.read()[:1000]
    target_sfAM.close()
    grab_ca = re.findall('Min. [X,Y,Z] = [0-9]+', read_sfAM)
    calibrate_axis = list(map(lambda x : int(x.split(' = ')[-1]),grab_ca))
    # Part of merge
    for n in range(len(trim_EP2)):
        trim_EP2[n][0] = trim_EP2[n][0] - calibrate_axis[0] + 1
        trim_EP2[n][1] = trim_EP2[n][1] - calibrate_axis[1] + 1
        trim_EP2[n][2] = trim_EP2[n][2] - calibrate_axis[2] + 1
    return trim_EP2
"""

def proj_xy_2d(path_of_sfam):
    target_sfam = open(path_of_sfam, 'rt', encoding = 'utf8')
    read_sfam = target_sfam.read()
    target_sfam.close()
    read_sfam.find('define Lattice')
    for item in read_sfam.split("\n"):
        if 'define Lattice' in item:
            key_lattice = item.strip()
        else:
            pass
    x_latti = int(key_lattice.split(' ')[-3]) #436
    y_latti = int(key_lattice.split(' ')[-2]) #328
    z_latti = int(key_lattice.split(' ')[-1]) #74
    for item in read_sfam.split("\n"):
        if 'Data section follows' in item:
            idx_dsf = read_sfam.split("\n").index(item.strip())
        else:
            pass
    if read_sfam.split("\n")[idx_dsf+1][0] == '@':
        pre_matrix = read_sfam.split("\n")[idx_dsf+2:]
    else:
        pass
    pre_ar1 = np.array(list(map(int, list(filter(None, pre_matrix)))))
    peel_mx = pre_ar1.reshape(z_latti, y_latti, x_latti)
    main_mx = np.transpose(peel_mx, (2, 1, 0)) # (436, 328, 74)
    ijz_li = []
    proj_face_xy = np.zeros((x_latti, y_latti), dtype=int)
    for i in range(x_latti):
        for j in range(y_latti):
            for k in range(z_latti):
                ijz_li.append(main_mx[i][j][k])
            proj_face_xy[i][j] = max(ijz_li)
            ijz_li = []
    return proj_face_xy

"""
def proj_xy_2d(path_of_sfam): # Old ver of proj
    target_sfam = open(path_of_sfam, 'rt', encoding = 'utf8')
    read_sfam = target_sfam.read()[:1500]
    target_sfam.close()
    read_sfam.find('define Lattice')
    for item in read_sfam.split("\n"):
        if 'define Lattice' in item:
            key_lattice = item.strip()
        else:
            pass
    x_latti = int(key_lattice.split(' ')[-3]) #436
    y_latti = int(key_lattice.split(' ')[-2]) #328
    z_latti = int(key_lattice.split(' ')[-1]) #74
    for item in read_sfam.split("\n"):
        if 'Data section follows' in item:
            idx_dsf = read_sfam.split("\n").index(item.strip())
        else:
            pass
    if read_sfam.split("\n")[idx_dsf+1][0] == '@':
        pre_matrix = read_sfam.split("\n")[idx_dsf+2:]
    else:
        pass
    pre_ar1 = np.array(list(map(int, list(filter(None, pre_matrix)))))
    peel_mx = pre_ar1.reshape(z_latti, y_latti, x_latti)
    main_mx = np.transpose(peel_mx, (2, 1, 0)) # (436, 328, 74)
    ijz_li = []
    proj_face_xy = np.zeros((x_latti, y_latti), dtype=int)
    for i in range(x_latti):
        for j in range(y_latti):
            for k in range(z_latti):
                ijz_li.append(main_mx[i][j][k])
            proj_face_xy[i][j] = max(ijz_li)
            ijz_li = []
    return proj_face_xy
"""

def rdm_pick_slice_no(number, rdm_list):
    record_name = rdm_list[number]
    count = 0
    while rdm_list[number] == rdm_list[number-1]:
        count += 1
        number += -1
    return [record_name, count]

"""
def rdm_pick_slice_no(number, rdm_list): # Too slow
    record_name = rdm_list[number]
    count = number - rdm_list.index(rdm_list[number])
    return [record_name, count]
"""

"""
def blsoco(soma_2D_coordi_li): #blsoco stands for BLock SOma COordinate
	block_x_posi = soma_2D_coordi_li[0] // 100
	block_y_posi = soma_2D_coordi_li[1] // 100
	soma_block = (block_x_posi, block_y_posi)
	return soma_block
"""

"""
def blexhush(original_matrix): # blexhush stands for BLock EXtend HUndred SHape
    hundred_matrix = np.pad(original_matrix,
                            ((0,100 - np.shape(original_matrix)[0] % 100),(0,100 - np.shape(original_matrix)[1] % 100)),
                            'constant',
                            constant_values=(0))
    hundred_slice_li = [ [0 for _ in range(int(np.shape(hundred_matrix)[1]/100))] for _ in range(int(np.shape(hundred_matrix)[0]/100))]
    for hs_i in range(int(np.shape(hundred_matrix)[0] / 100)): # 500 / 100 = 5
        for hs_j in range(int(np.shape(hundred_matrix)[1] / 100)): # 400 / 100 = 4
            hundred_slice_li[hs_i][hs_j] = hundred_matrix[hs_i:hs_i+100,hs_j:hs_j+100]
    return list(hundred_slice_li)
"""

def happy_time(start,stop):
    process_time = round(stop - start)
    ss = process_time % 60
    mm = process_time // 60 % 60
    hh = process_time // 3600
    duration = "Process time == {}s == {}H {}m {}s".format(process_time,hh,mm,ss)
    return duration

def mx_preview(array):
    #plt.figure(figsize=(8, 8))
    plt.imshow(array, aspect = 'equal', interpolation='nearest')
    plt.title('Preview of(x, y) = {}'.format(np.shape(array)),
              fontsize = 20, y=1.05)
    plt.xlabel('Y', fontsize = 20)
    plt.ylabel('X', fontsize = 20)
    plt.colorbar(fraction=0.04, pad=0.1)
    return plt.show()

def sth(train_history, train, validation): # sth stands for show_train_history
    plt.plot(train_history.history[train])
    plt.plot(train_history.history[validation])
    plt.title('Train History')
    plt.ylabel(train)
    plt.xlabel('Epoch')
    plt.legend(['train', 'validation'], loc = 'upper left')
    return plt.show()

"""
 def projection_plot(matrix):
    proj_for_plot = matrix # to replace the original line above
    plt.figure(figsize=(10,10))
    plt.imshow(proj_for_plot, cmap = "gray",  aspect = 'equal')
    plt.show()
    return print('Shape of matrix projection:',np.shape(proj_for_plot))
"""

def plot_images_labels_prediction(images, labels, prediction, idx, num = 30): # From BOOK
    fig = plt.gcf()
    fig.set_size_inches(12, 14)
    if num > 30: num = 30 
    for i in range(0, num):
        ax = plt.subplot(6, 5, 1+i)
        ax.imshow(images[idx],)
        title = "label=" + str(labels[idx])
        if len(prediction) > 0:
            title += ", predict=" + str(prediction[idx]) 
        ax.set_title(title, fontsize = 10) 
        ax.set_xticks([]); ax.set_yticks([])        
        idx += 1 
    plt.show()
